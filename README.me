  Для детектирования я использовал предобученную модель maskrcnn из torchvision. Заменил только слои mask_predictor и box_predictor. Я пробовал две версии модели:
  1) Модель, в которой все слои не обучаются, кроме слоя rpn и roi_heads
  2) Модель, в которой все слои не обучаются, кроме слоя rpn, roi_heads и backbone.fpn
В итоге заметил одну интересную особенность. У первой модели bounding box получались лучше, однако она с трудом отличала текст на машине (особенно белый текст на черной машине или черный текст на белой машине) от номера (мог поставить высокий скор, больший даже, чем у номера (0.95 против 0.94)). В итоге для детекция я использовал именно первую модель. Особо интересеных преобразований с данными я не делал. Я отсортировал  точки, чтобы они были расположены по часовой стрелке и просто заполнил bounding box, используя cv2.fillConvexPoly. Аугментаций не делал. Модель обучал одну эпоху, так как лосс на ней уже перестал падать. Был интересный баг, когда у меня bounding box'ы предсказывались отзеркалено. Долго пытался понять, в чем проблема, пока не понял, что в датасете перепутал x и y.
Перед тем, как начать обучать модель респознавания, я сделал новый датасет, вырезав номера, используя размеченные bounding box'ы, и проективным преобразованием приведя их к прямоугольному виду. Для распознавания я использовал модель CRNN, в точности взятую из семинаров. В датасете есть номера, которые написаны неправильно, поэтому я не обучался на номерах маска которых не совпадала с одной из следующих: 'LDDDLLDDD', 'LDDDLLDD' и 'LLDDDLDD'. Так же я перевёл все номера в верхний регистр и на английский язык. Изначально я не делал никаких аугментаций, кроме resize (что позже сильно пинизило качество работы модели). Обучал я её 2 эпохи, больше особого смысла не было обучать, так как лосс уже не уменьшался. 
Итоговый пайплайн состоял из следующих этапов:
  1) Нахождение маски номеров
  2) Нахождения контура маски с помощью cv2.findContours (важное замечание, данная функция может найти больше одного контура, причём первый найденный контур может оказаться обводкой какого-то маленького региона. Поэтому я среди найденных контуров выбирал максимальный по площади)
  3) Приближал контур четырёхугольником
  4) Вырезал и выравнивал контур, используя проективное преобразование
  5) Распознавал буквы на таблички
Однако, так как я не делал никаких аугментаций при обучениий CRNN, когда masrcnn плохо детектировала маску и в итоге вырезанная табличка получалась скошенной модель очень плохо распознавала буквы. В итоге я подсмотрел идею и так же добавил в датасет для обучения CRNN номера, к которым я не применял проективное преобразование, а просто вырезал, вместе с областью вокруг них (вырезал, просто используя минимальные/максимальный x и y bounding box'ов). (Надеюсь понятно объяснил). Так же я пытался в предсказание отсечь все номера, макси которых не совпадают с 'LDDDLLDDD', 'LDDDLLDD' и 'LLDDDLDD'. Однако это только ухудшило мой скор. Судя по чату эта идея хороша, но видимо моя модельнедостаточно хорошо предсказывала.

Ps. Большое спасибо за этот курс и выданные машины. Это по сути мой первый курс по нейросетям и мне очень понравилось, как тут всё доступно и понятно объяснили. Очень крутой и полезный курс!
